% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Conclusion}
\label{cap:conclusions}
%**************************************************************.

The thesis work was mainly divided into two phases: the first research phase, both for the fundamental 
themes of distributed systems and for programming languages for smart contracts; the second stage of 
architecture development. The second phase however involved a research activity, aimed however at finding 
implementation solutions. The first research phase lasted from October to December 2022, while the design 
and development of the entire architecture lasted from December 2022 until the beginning of April 2023.

\section{Design considerations}

The design took a long time to organize the fundamental concepts of the architecture, such as organizing 
the components and managing their interactions. In particular, a lot of time was required to design:
\begin{enumerate}
  \item \textit{Virtual Machine} and \textit{Stipula bytecode}
  \item Asset management and \textit{Script} language
  \item Distributed context and consent
\end{enumerate}

\subsection{Virtual Machine and Stipula bytecode}

The decision to make the \textit{Stipula} language a compiled language required the creation of a target 
language for execution, namely, the \textit{Stipula bytecode}. The design of this language took some time 
to devise the necessary \textit{statements}. The goal was to create a minimal set of instructions that 
would allow for the implementation of all aspects of the high-level language, trying not to make the set 
of instructions too large, but to reuse the existing instructions as much as possible. Even the design of 
the virtual machine was not trivial as the goal was to create a component that would allow for the 
execution of a contract in isolation from the other components of the architecture.

\subsection{Asset Management and Script Language}

The implementation of a UTXO model is more complex than the account-balance-based model, both from a 
theoretical point of view and from an implementation point of view. The UTXO model requires you to 
understand a different approach than classic balance sheet management. Furthermore, the cryptographic 
aspect combined with asset management complicates the understanding more. However, this model has important 
advantages for the application context, such as the possibility of cryptographically verifying the 
ownership of the funds. By doing so, there can be no contract that could misappropriate your funds. It is 
always the user who approves an asset transfer to a contract. Connected to the UTXO model, the 
understanding, design and implementation of the \textit{Script} language was also not trivial. 
Understanding the usefulness of this language is not trivial, as at first glance it might seem like a 
useless complication to architecture. Instead, as has been explained in this thesis work, the advantage of 
the \textit{Script} language is twofold: firstly, it allows to cryptographically demonstrate the ownership 
of a user's funds; secondly, the extensibility of this language will make it possible to expand the 
methods of transferring assets, minimizing the architectural modules to be updated.

The idea of reproducing Ethereum/Algorand-style assets and combining the UTXO model was not trivial. 
Ethereum tokens and Algorand assets use a classic account-balance-based model and therefore their 
functions for smart contracts also adapt to this model. The use of a UTXO model has overturned the 
classic interaction between the user and the contracts of Ethereum and Algorand.

\subsection{Distributed context and consent}

The entire research phase and the design phase have always taken into consideration the distributed 
context. In fact, all the design choices have been made taking into consideration that in the future the 
current architecture will be placed in a possible distributed system. Then the components and modules 
needed to adapt the current architecture for a distributed system were also thought of. In the research 
phase, various problems of distributed systems were analyzed and raised, such as the consensus between 
the nodes of a network. It is a very interesting topic which would require just as much time to study and 
propose a solution to be integrated into the current project. Due to lack of time, it was not possible to 
study these topics further.

\section{Implementation consideration}

The project consists of approximately \textbf{15,000 lines of code}, of which approximately \textit{4,500} 
were generated by the ANTLR tool. The code is divided into \textbf{107 classes} and in the repository there 
is a \textbf{graph of the dependencies} between the various classes and the various packages 
\autocite{site:stipula-github-graph-dependencies}. Most of the code is dedicated to the development of the 
\textit{Virtual Machine}, the \textit{Stipula bytecode} and the \textit{compiler}, as they are the most 
complex components of the whole architecture. In particular:
\begin{enumerate}
  \item \textit{Stipula bytecode} and \textit{Virtual Machine} (23 classes and 3121 lines of code):
  \begin{enumerate}
    \item \textit{Stipula bytecode}: the implementation of the language required a lot of code as it was 
    necessary to implement all its instructions. For each instruction, the necessary checks must be carried 
    out to avoid unwanted behaviour;
    \item \textit{Virtual Machine}: this module required a lot of code as it has to handle a very complex 
    flow. Must consider receiving and sending payments (\textit{Pay-to-Contract} and \textit{Pay-to-Party}). 
    In particular, for \textit{Pay-to-Contract} it is necessary to check whether the user is the effective 
    owner of the funds. This module also deals with managing communication with the client and also managing 
    the scheduling of obligations;
  \end{enumerate}
  \item \textit{Compiler} (28 classes and 6261 lines of code with ANTLR tool, 21 classes and 3007 lines of 
  code without the code generated by ANTLR): this module requires a lot of code 
  (excluding the one generated by ANTLR) to be able to visit the \textit{abstract syntax tree} and then to 
  map the \textit{Stipula} statements into the \textit{Specify bytecode} statement.
\end{enumerate}

\subsection{Structure of the project}

The project repository \autocite{site:stipula-github} is organized as follows:
\begin{enumerate}
  \item \verb|.github/workflows|: contains the pipelines described in the \ref{pipelines} section and in 
  the \ref{app:pipeline} appendix;
  \item \verb|examples|: this folder contains example contracts (see the \ref{examples} section) and 
  example code pieces written in \textit{Stipula bytecode};
  \item \verb|gradle/wrapper|, \verb|build.gradle|, \verb|gradlew|, \verb|gradlew.bat| and 
  \verb|settings.gradle|: files needed for Gradle;
  \item \verb|src|: contains the architecture implementation code;
  \item \verb|Dockerfile|: it is the file that allows you to create a Docker image (see the appendix 
  \ref{app:docker});
  \item \verb|README.md|: it is a file that introduces the project, its use, the available features and 
  the installation process;
  \item \verb|docker-compose.yml|: is a file that allows you to run a Docker container (see the appendix 
  \ref{app:docker});
\end{enumerate}

\subsubsection{src}

The structure of the \verb|src| folder it's the following:
\begin{enumerate}
  \item \verb|main/java|: contains the architecture implementation code;
  \item \verb|test/java|: currently, contains only an example test. In the future, all architecture 
  tests will be collected.
\end{enumerate}

\subsubsection{main/java}

The structure of the \verb|main/java| folder it's the following:
\begin{enumerate}
   \item \verb|compiler|: contains all the code related to the compiler implementation (see section 
   \ref{compiler});
   \item \verb|constants|: contains a file containing the \textit{constants} shared between the various modules;
   \item \verb|exceptions|: contains classes that implement exceptions for data structures;
   \item \verb|lib|: contains the code of some libraries in common with the other modules (see section 
   \ref{libraries});
   \newpage
   \item \verb|models|:
     \begin{enumerate}
       \item \verb|assets|: contains the code that allows you to implement \textit{assets} (see the 
       \ref{asset-implementation} section);
       \item \verb|contract|: contains the code that implements \textit{contracts} and 
       \textit{contract instances} (see section \ref{contract-and-contract-instances-implementation}), \textit {Pay-to-Contract}, \verb|Ownership| (see section \ref{ownership}) and 
       \textit{single-use-seals} (see section \ref{single-use-seals-and-ownerships}) 
       \ref{pay-to-contract};
       \item \verb|dto|:
         \begin{enumerate}
           \item \verb|requests|: contains the code for implementing the messages defined in the 
           \ref{messages} section;
           \item \verb|responses|: contains the code for the responses to be sent to the client;
         \end{enumerate}
       \item \verb|party|: contains the code for implementing a \textit{party} (see paragraph 
       \ref{party-implementation});
     \end{enumerate}
   \item \verb|server|: contains the code implementing the \textit{Message Service} module (see the \ref{message-service} section);
   \item \verb|shared|: implements a shared memory area between the virtual machine and the \verb|ClientHandler| (see \ref{shared-memory});
   \item \verb|storage|: contains the code implementing the \textit{Storage} module (see the \ref{storage} section);
   \item \verb|vm|: contains all the code that implements the \textit{Virtual Machine} module (see the 
   \ref{virtual-machine} section) and the implementation of the \textit{Stipula bytecode} (see the section \ref{stipula-bytecode});
   \item \verb|Main.java|: it is the main file from which it is possible to start the implementation instance;
\end{enumerate}
